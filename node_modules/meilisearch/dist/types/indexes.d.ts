import { Config, Task, SearchResponse, SearchParams, IndexObject, IndexOptions, IndexStats, DocumentsQuery, DocumentQuery, Document, DocumentOptions, EnqueuedTask, Settings, Synonyms, StopWords, RankingRules, DistinctAttribute, FilterableAttributes, SortableAttributes, SearchableAttributes, DisplayedAttributes, TypoTolerance, WaitOptions, DocumentsResults, TasksQuery, TasksResults } from './types';
import { HttpRequests } from './http-requests';
import { TaskClient } from './task';
declare class Index<T = Record<string, any>> {
    uid: string;
    primaryKey: string | undefined;
    createdAt: Date | undefined;
    updatedAt: Date | undefined;
    httpRequest: HttpRequests;
    tasks: TaskClient;
    /**
     * @param {Config} config Request configuration options
     * @param {string} uid UID of the index
     * @param {string} [primaryKey] Primary Key of the index
     */
    constructor(config: Config, uid: string, primaryKey?: string);
    /**
     * Search for documents into an index
     * @memberof Index
     * @method search
     * @template T
     * @param {string | null} query? Query string
     * @param {SearchParams} options? Search options
     * @param {Partial<Request>} config? Additional request configuration options
     * @returns {Promise<SearchResponse<T>>} Promise containing the search response
     */
    search<T = Record<string, any>>(query?: string | null, options?: SearchParams, config?: Partial<Request>): Promise<SearchResponse<T>>;
    /**
     * Search for documents into an index using the GET method
     * @memberof Index
     * @method search
     * @template T
     * @param {string | null} query? Query string
     * @param {SearchParams} options? Search options
     * @param {Partial<Request>} config? Additional request configuration options
     * @returns {Promise<SearchResponse<T>>} Promise containing the search response
     */
    searchGet<T = Record<string, any>>(query?: string | null, options?: SearchParams, config?: Partial<Request>): Promise<SearchResponse<T>>;
    /**
     * Get index information.
     * @memberof Index
     * @method getRawInfo
     *
     * @returns {Promise<IndexObject>} Promise containing index information
     */
    getRawInfo(): Promise<IndexObject>;
    /**
     * Fetch and update Index information.
     * @memberof Index
     * @method fetchInfo
     * @returns {Promise<this>} Promise to the current Index object with updated information
     */
    fetchInfo(): Promise<this>;
    /**
     * Get Primary Key.
     * @memberof Index
     * @method fetchPrimaryKey
     * @returns {Promise<string | undefined>} Promise containing the Primary Key of the index
     */
    fetchPrimaryKey(): Promise<string | undefined>;
    /**
     * Create an index.
     * @memberof Index
     * @method create
     * @template T
     * @param {string} uid Unique identifier of the Index
     * @param {IndexOptions} options Index options
     * @param {Config} config Request configuration options
     * @returns {Promise<Index<T>>} Newly created Index object
     */
    static create(uid: string, options: IndexOptions | undefined, config: Config): Promise<EnqueuedTask>;
    /**
     * Update an index.
     * @memberof Index
     * @method update
     * @param {IndexOptions} data Data to update
     * @returns {Promise<this>} Promise to the current Index object with updated information
     */
    update(data: IndexOptions): Promise<EnqueuedTask>;
    /**
     * Delete an index.
     * @memberof Index
     * @method delete
     * @returns {Promise<void>} Promise which resolves when index is deleted successfully
     */
    delete(): Promise<EnqueuedTask>;
    /**
     * Get the list of all the tasks of the index.
     *
     * @memberof Indexes
     * @method getTasks
     * @param {TasksQuery} [parameters={}] - Parameters to browse the tasks
     *
     * @returns {Promise<TasksResults>} - Promise containing all tasks
     */
    getTasks(parameters?: TasksQuery): Promise<TasksResults>;
    /**
     * Get one task of the index.
     *
     * @memberof Indexes
     * @method getTask
     * @param {number} taskUid - Task identifier
     *
     * @returns {Promise<Task>} - Promise containing a task
     */
    getTask(taskUid: number): Promise<Task>;
    /**
     * Wait for multiple tasks to be processed.
     *
     * @memberof Indexes
     * @method waitForTasks
     * @param {number[]} taskUids - Tasks identifier
     * @param {WaitOptions} waitOptions - Options on timeout and interval
     *
     * @returns {Promise<Task[]>} - Promise containing an array of tasks
     */
    waitForTasks(taskUids: number[], { timeOutMs, intervalMs }?: WaitOptions): Promise<Task[]>;
    /**
     * Wait for a task to be processed.
     *
     * @memberof Indexes
     * @method waitForTask
     * @param {number} taskUid - Task identifier
     * @param {WaitOptions} waitOptions - Options on timeout and interval
     *
     * @returns {Promise<Task>} - Promise containing an array of tasks
     */
    waitForTask(taskUid: number, { timeOutMs, intervalMs }?: WaitOptions): Promise<Task>;
    /**
     * get stats of an index
     * @memberof Index
     * @method getStats
     * @returns {Promise<IndexStats>} Promise containing object with stats of the index
     */
    getStats(): Promise<IndexStats>;
    /**
     * get documents of an index
     * @memberof Index
     * @method getDocuments
     * @template T
     * @param {DocumentsQuery<T>} [parameters={}] Parameters to browse the documents
     * @returns {Promise<DocumentsResults<T>>>} Promise containing Document responses
     */
    getDocuments<T = Record<string, any>>(parameters?: DocumentsQuery<T>): Promise<DocumentsResults<T>>;
    /**
     * Get one document
     * @memberof Index
     * @method getDocument
     * @template T
     * @param {string | number} documentId Document ID
     * @param {DocumentQuery<T>} [parameters={}] Parameters applied on a document
     * @returns {Promise<Document<T>>} Promise containing Document response
     */
    getDocument<T = Record<string, any>>(documentId: string | number, parameters?: DocumentQuery<T>): Promise<Document<T>>;
    /**
     * Add or replace multiples documents to an index
     * @memberof Index
     * @method addDocuments
     * @template T
     * @param {Array<Document<T>>} documents Array of Document objects to add/replace
     * @param {DocumentOptions} options? Options on document addition
     *
     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued task
     */
    addDocuments(documents: Array<Document<T>>, options?: DocumentOptions): Promise<EnqueuedTask>;
    /**
     * Add or replace multiples documents to an index in batches
     * @memberof Index
     * @method addDocumentsInBatches
     * @template T
     * @param {Array<Document<T>>} documents Array of Document objects to add/replace
     * @param {number} batchSize Size of the batch
     * @param {DocumentOptions} options? Options on document addition
     * @returns {Promise<EnqueuedTasks>} Promise containing array of enqueued task objects for each batch
     */
    addDocumentsInBatches(documents: Array<Document<T>>, batchSize?: number, options?: DocumentOptions): Promise<EnqueuedTask[]>;
    /**
     * Add or update multiples documents to an index
     * @memberof Index
     * @method updateDocuments
     * @param {Array<Document<Partial<T>>>} documents Array of Document objects to add/update
     * @param {DocumentOptions} options? Options on document update
     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued task
     */
    updateDocuments(documents: Array<Document<Partial<T>>>, options?: DocumentOptions): Promise<EnqueuedTask>;
    /**
     * Add or update multiples documents to an index in batches
     * @memberof Index
     * @method updateDocuments
     * @template T
     * @param {Array<Document<T>>} documents Array of Document objects to add/update
     * @param {number} batchSize Size of the batch
     * @param {DocumentOptions} options? Options on document update
     * @returns {Promise<EnqueuedTasks>} Promise containing array of enqueued task objects for each batch
     */
    updateDocumentsInBatches(documents: Array<Document<Partial<T>>>, batchSize?: number, options?: DocumentOptions): Promise<EnqueuedTask[]>;
    /**
     * Delete one document
     * @memberof Index
     * @method deleteDocument
     * @param {string | number} documentId Id of Document to delete
     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued task
     */
    deleteDocument(documentId: string | number): Promise<EnqueuedTask>;
    /**
     * Delete multiples documents of an index
     * @memberof Index
     * @method deleteDocuments
     * @param {string[] | number[]} documentsIds Array of Document Ids to delete
     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued task
     */
    deleteDocuments(documentsIds: string[] | number[]): Promise<EnqueuedTask>;
    /**
     * Delete all documents of an index
     * @memberof Index
     * @method deleteAllDocuments
     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued task
     */
    deleteAllDocuments(): Promise<EnqueuedTask>;
    /**
     * Retrieve all settings
     * @memberof Index
     * @method getSettings
     * @returns {Promise<Settings>} Promise containing Settings object
     */
    getSettings(): Promise<Settings>;
    /**
     * Update all settings
     * Any parameters not provided will be left unchanged.
     * @memberof Index
     * @method updateSettings
     * @param {Settings} settings Object containing parameters with their updated values
     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued task
     */
    updateSettings(settings: Settings): Promise<EnqueuedTask>;
    /**
     * Reset settings.
     * @memberof Index
     * @method resetSettings
     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued task
     */
    resetSettings(): Promise<EnqueuedTask>;
    /**
     * Get the list of all synonyms
     * @memberof Index
     * @method getSynonyms
     * @returns {Promise<object>} Promise containing object of synonym mappings
     */
    getSynonyms(): Promise<object>;
    /**
     * Update the list of synonyms. Overwrite the old list.
     * @memberof Index
     * @method updateSynonyms
     * @param {Synonyms} synonyms Mapping of synonyms with their associated words
     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued task
     */
    updateSynonyms(synonyms: Synonyms): Promise<EnqueuedTask>;
    /**
     * Reset the synonym list to be empty again
     * @memberof Index
     * @method resetSynonyms
     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued task
     */
    resetSynonyms(): Promise<EnqueuedTask>;
    /**
     * Get the list of all stop-words
     * @memberof Index
     * @method getStopWords
     * @returns {Promise<string[]>} Promise containing array of stop-words
     */
    getStopWords(): Promise<string[]>;
    /**
     * Update the list of stop-words. Overwrite the old list.
     * @memberof Index
     * @method updateStopWords
     * @param {StopWords} stopWords Array of strings that contains the stop-words.
     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued task
     */
    updateStopWords(stopWords: StopWords): Promise<EnqueuedTask>;
    /**
     * Reset the stop-words list to be empty again
     * @memberof Index
     * @method resetStopWords
     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued task
     */
    resetStopWords(): Promise<EnqueuedTask>;
    /**
     * Get the list of all ranking-rules
     * @memberof Index
     * @method getRankingRules
     * @returns {Promise<string[]>} Promise containing array of ranking-rules
     */
    getRankingRules(): Promise<string[]>;
    /**
     * Update the list of ranking-rules. Overwrite the old list.
     * @memberof Index
     * @method updateRankingRules
     * @param {RankingRules} rankingRules Array that contain ranking rules sorted by order of importance.
     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued task
     */
    updateRankingRules(rankingRules: RankingRules): Promise<EnqueuedTask>;
    /**
     * Reset the ranking rules list to its default value
     * @memberof Index
     * @method resetRankingRules
     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued task
     */
    resetRankingRules(): Promise<EnqueuedTask>;
    /**
     * Get the distinct-attribute
     * @memberof Index
     * @method getDistinctAttribute
     * @returns {Promise<string | null>} Promise containing the distinct-attribute of the index
     */
    getDistinctAttribute(): Promise<string | null>;
    /**
     * Update the distinct-attribute.
     * @memberof Index
     * @method updateDistinctAttribute
     * @param {DistinctAttribute} distinctAttribute Field name of the distinct-attribute
     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued task
     */
    updateDistinctAttribute(distinctAttribute: DistinctAttribute): Promise<EnqueuedTask>;
    /**
     * Reset the distinct-attribute.
     * @memberof Index
     * @method resetDistinctAttribute
     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued task
     */
    resetDistinctAttribute(): Promise<EnqueuedTask>;
    /**
     * Get the filterable-attributes
     * @memberof Index
     * @method getFilterableAttributes
     * @returns {Promise<string[]>} Promise containing an array of filterable-attributes
     */
    getFilterableAttributes(): Promise<string[]>;
    /**
     * Update the filterable-attributes.
     * @memberof Index
     * @method updateFilterableAttributes
     * @param {FilterableAttributes} filterableAttributes Array of strings containing the attributes that can be used as filters at query time
     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued task
     */
    updateFilterableAttributes(filterableAttributes: FilterableAttributes): Promise<EnqueuedTask>;
    /**
     * Reset the filterable-attributes.
     * @memberof Index
     * @method resetFilterableAttributes
     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued task
     */
    resetFilterableAttributes(): Promise<EnqueuedTask>;
    /**
     * Get the sortable-attributes
     * @memberof Index
     * @method getSortableAttributes
     * @returns {Promise<string[]>} Promise containing array of sortable-attributes
     */
    getSortableAttributes(): Promise<string[]>;
    /**
     * Update the sortable-attributes.
     * @memberof Index
     * @method updateSortableAttributes
     * @param {SortableAttributes} sortableAttributes Array of strings containing the attributes that can be used to sort search results at query time
     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued task
     */
    updateSortableAttributes(sortableAttributes: SortableAttributes): Promise<EnqueuedTask>;
    /**
     * Reset the sortable-attributes.
     * @memberof Index
     * @method resetSortableAttributes
     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued task
     */
    resetSortableAttributes(): Promise<EnqueuedTask>;
    /**
     * Get the searchable-attributes
     * @memberof Index
     * @method getSearchableAttributes
     * @returns {Promise<string[]>} Promise containing array of searchable-attributes
     */
    getSearchableAttributes(): Promise<string[]>;
    /**
     * Update the searchable-attributes.
     * @memberof Index
     * @method updateSearchableAttributes
     * @param {SearchableAttributes} searchableAttributes Array of strings that contains searchable attributes sorted by order of importance(most to least important)
     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued task
     */
    updateSearchableAttributes(searchableAttributes: SearchableAttributes): Promise<EnqueuedTask>;
    /**
     * Reset the searchable-attributes.
     * @memberof Index
     * @method resetSearchableAttributes
     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued task
     */
    resetSearchableAttributes(): Promise<EnqueuedTask>;
    /**
     * Get the displayed-attributes
     * @memberof Index
     * @method getDisplayedAttributes
     * @returns {Promise<string[]>} Promise containing array of displayed-attributes
     */
    getDisplayedAttributes(): Promise<string[]>;
    /**
     * Update the displayed-attributes.
     * @memberof Index
     * @method updateDisplayedAttributes
     * @param {DisplayedAttributes} displayedAttributes Array of strings that contains attributes of an index to display
     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued task
     */
    updateDisplayedAttributes(displayedAttributes: DisplayedAttributes): Promise<EnqueuedTask>;
    /**
     * Reset the displayed-attributes.
     * @memberof Index
     * @method resetDisplayedAttributes
     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued task
     */
    resetDisplayedAttributes(): Promise<EnqueuedTask>;
    /**
     * Get the typo tolerance settings.
     * @memberof Index
     * @method getTypoTolerance
     * @returns {Promise<string[]>} Promise containing the typo tolerance settings.
     */
    getTypoTolerance(): Promise<string[]>;
    /**
     * Update the typo tolerance settings.
     * @memberof Index
     * @method updateTypoTolerance
     * @param {TypoTolerance} typoTolerance Object containing the custom typo tolerance settings.
     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued update
     */
    updateTypoTolerance(typoTolerance: TypoTolerance): Promise<EnqueuedTask>;
    /**
     * Reset the typo tolerance settings.
     * @memberof Index
     * @method resetTypoTolerance
     * @returns {Promise<EnqueuedTask>} Promise containing object of the enqueued update
     */
    resetTypoTolerance(): Promise<EnqueuedTask>;
}
export { Index };
//# sourceMappingURL=indexes.d.ts.map