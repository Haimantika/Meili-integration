import { Index } from '../indexes';
import { KeyCreation, Config, IndexOptions, IndexObject, EnqueuedTask, Key, Health, Stats, Version, Task, TokenSearchRules, TokenOptions, TasksQuery, WaitOptions, KeyUpdate, IndexesQuery, IndexesResults, KeysQuery, KeysResults, TasksResults } from '../types';
import { HttpRequests } from '../http-requests';
import { TaskClient } from '../task';
declare class Client {
    config: Config;
    httpRequest: HttpRequests;
    tasks: TaskClient;
    /**
     * Creates new MeiliSearch instance
     * @param {Config} config Configuration object
     */
    constructor(config: Config);
    /**
     * Return an Index instance
     * @memberof MeiliSearch
     * @method index
     * @template T
     * @param {string} indexUid The index UID
     * @returns {Index<T>} Instance of Index
     */
    index<T = any>(indexUid: string): Index<T>;
    /**
     * Gather information about an index by calling MeiliSearch and
     * return an Index instance with the gathered information
     * @memberof MeiliSearch
     * @method getIndex
     * @template T
     * @param {string} indexUid The index UID
     * @returns {Promise<Index<T>>} Promise returning Index instance
     */
    getIndex<T = any>(indexUid: string): Promise<Index<T>>;
    /**
     * Gather information about an index by calling MeiliSearch and
     * return the raw JSON response
     * @memberof MeiliSearch
     * @method getRawIndex
     * @param {string} indexUid The index UID
     * @returns {Promise<IndexObject>} Promise returning index information
     */
    getRawIndex(indexUid: string): Promise<IndexObject>;
    /**
     * Get all the indexes as Index instances.
     * @memberof MeiliSearch
     * @method getIndexes
     * @param {IndexesQuery} [parameters={}] - Parameters to browse the indexes
     *
     * @returns {Promise<IndexesResults<Index[]>>} Promise returning array of raw index information
     */
    getIndexes(parameters?: IndexesQuery): Promise<IndexesResults<Index[]>>;
    /**
     * Get all the indexes in their raw value (no Index instances).
     * @memberof MeiliSearch
     * @method getRawIndexes
     * @param {IndexesQuery} [parameters={}] - Parameters to browse the indexes
     *
     * @returns {Promise<IndexesResults<IndexObject[]>>} Promise returning array of raw index information
     */
    getRawIndexes(parameters?: IndexesQuery): Promise<IndexesResults<IndexObject[]>>;
    /**
     * Create a new index
     * @memberof MeiliSearch
     * @method createIndex
     * @template T
     * @param {string} uid The index UID
     * @param {IndexOptions} options Index options
     * @returns {Promise<Index<T>>} Promise returning Index instance
     */
    createIndex(uid: string, options?: IndexOptions): Promise<EnqueuedTask>;
    /**
     * Update an index
     * @memberof MeiliSearch
     * @method updateIndex
     * @template T
     * @param {string} uid The index UID
     * @param {IndexOptions} options Index options to update
     * @returns {Promise<Index<T>>} Promise returning Index instance after updating
     */
    updateIndex(uid: string, options?: IndexOptions): Promise<EnqueuedTask>;
    /**
     * Delete an index
     * @memberof MeiliSearch
     * @method deleteIndex
     * @param {string} uid The index UID
     * @returns {Promise<void>} Promise which resolves when index is deleted successfully
     */
    deleteIndex(uid: string): Promise<EnqueuedTask>;
    /**
     * Deletes an index if it already exists.
     * @memberof MeiliSearch
     * @method deleteIndexIfExists
     * @param {string} uid The index UID
     * @returns {Promise<boolean>} Promise which resolves to true when index exists and is deleted successfully, otherwise false if it does not exist
     */
    deleteIndexIfExists(uid: string): Promise<boolean>;
    /**
     * Get the list of all client tasks
     * @memberof MeiliSearch
     * @method getTasks
     * @param {TasksQuery} [parameters={}] - Parameters to browse the tasks
     *
     * @returns {Promise<TasksResults>} - Promise returning all tasks
     */
    getTasks(parameters?: TasksQuery): Promise<TasksResults>;
    /**
     * Get one task on the client scope
     * @memberof MeiliSearch
     * @method getTask
     * @param {number} taskUid - Task identifier
     * @returns {Promise<Task>} - Promise returning a task
     */
    getTask(taskUid: number): Promise<Task>;
    /**
     * Wait for multiple tasks to be finished.
     *
     * @memberof MeiliSearch
     * @method waitForTasks
     * @param {number[]} taskUids - Tasks identifier
     * @param {WaitOptions} waitOptions - Options on timeout and interval
     *
     * @returns {Promise<Task[]>} - Promise returning an array of tasks
     */
    waitForTasks(taskUids: number[], { timeOutMs, intervalMs }?: WaitOptions): Promise<Task[]>;
    /**
     * Wait for a task to be finished.
     *
     * @memberof MeiliSearch
     * @method waitForTask
     *
     * @param {number} taskUid - Task identifier
     * @param {WaitOptions} waitOptions - Options on timeout and interval
     *
     * @returns {Promise<Task>} - Promise returning an array of tasks
     */
    waitForTask(taskUid: number, { timeOutMs, intervalMs }?: WaitOptions): Promise<Task>;
    /**
     * Get all API keys
     * @memberof MeiliSearch
     * @method getKeys
     * @param {KeysQuery} [parameters={}] - Parameters to browse the indexes
     *
     * @returns {Promise<KeysResults>} Promise returning an object with keys
     */
    getKeys(parameters?: KeysQuery): Promise<KeysResults>;
    /**
     * Get one API key
     * @memberof MeiliSearch
     * @method getKey
     *
     * @param {string} keyOrUid - Key or uid of the API key
     * @returns {Promise<Key>} Promise returning a key
     */
    getKey(keyOrUid: string): Promise<Key>;
    /**
     * Create one API key
     * @memberof MeiliSearch
     * @method createKey
     *
     * @param {KeyCreation} options - Key options
     * @returns {Promise<Key>} Promise returning a key
     */
    createKey(options: KeyCreation): Promise<Key>;
    /**
     * Update one API key
     * @memberof MeiliSearch
     * @method updateKey
     *
     * @param {string} keyOrUid - Key
     * @param {KeyUpdate} options - Key options
     * @returns {Promise<Key>} Promise returning a key
     */
    updateKey(keyOrUid: string, options: KeyUpdate): Promise<Key>;
    /**
     * Delete one API key
     * @memberof MeiliSearch
     * @method deleteKey
     *
     * @param {string} keyOrUid - Key
     * @returns {Promise<Void>}
     */
    deleteKey(keyOrUid: string): Promise<void>;
    /**
     * Checks if the server is healthy, otherwise an error will be thrown.
     * @memberof MeiliSearch
     * @method health
     * @returns {Promise<Health>} Promise returning an object with health details
     */
    health(): Promise<Health>;
    /**
     * Checks if the server is healthy, return true or false.
     * @memberof MeiliSearch
     * @method isHealthy
     * @returns {Promise<boolean>} Promise returning a boolean
     */
    isHealthy(): Promise<boolean>;
    /**
     * Get the stats of all the database
     * @memberof MeiliSearch
     * @method getStats
     * @returns {Promise<Stats>} Promise returning object of all the stats
     */
    getStats(): Promise<Stats>;
    /**
     * Get the version of MeiliSearch
     * @memberof MeiliSearch
     * @method getVersion
     * @returns {Promise<Version>} Promise returning object with version details
     */
    getVersion(): Promise<Version>;
    /**
     * Creates a dump
     * @memberof MeiliSearch
     * @method createDump
     * @returns {Promise<EnqueuedTask>} Promise returning object of the enqueued task
     */
    createDump(): Promise<EnqueuedTask>;
    /**
     * Generate a tenant token
     *
     * @memberof MeiliSearch
     * @method generateTenantToken
     * @param {apiKeyUid} apiKeyUid The uid of the api key used as issuer of the token.
     * @param {SearchRules} searchRules Search rules that are applied to every search.
     * @param {TokenOptions} options Token options to customize some aspect of the token.
     *
     * @returns {String} The token in JWT format.
     */
    generateTenantToken(_apiKeyUid: string, _searchRules: TokenSearchRules, _options?: TokenOptions): string;
}
export { Client };
//# sourceMappingURL=client.d.ts.map